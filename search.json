[{"title":"Fragment的跳转 碎片","url":"/2022/08/02/Fragemnt/","content":"代码构成MainActivity类\n\n对tablayout进行监听\n函数onTabSelected(TabLayout.Tab tab) 利用switch按顺序选择未使用图标时的操作\n函数onTabUnselected(TabLayout.Tab tab)利用switch按顺序选择是哦那个时的导航栏图标的操作\n\n\nMe、News、Toolbox类：是每个碎片的内容\nViewPagerAdapter类设置导航栏格式\nactivity_main.xml设置viewpager与TabLayout的分布\nfragment_me.xml、fragment_news.xml、fragment_toolbox.xml是每个碎片的设计\ntablayout.xml\n","categories":["android学习"],"tags":["android"]},{"title":"Android 第一章","url":"/2022/05/15/android-%E7%AC%AC%E4%B8%80%E7%AB%A0/","content":"Android的安装Android项目的建立log日志的使用","categories":["android学习"],"tags":["android"]},{"title":"Android 第三章","url":"/2022/07/05/android-%E7%AC%AC%E4%B8%89%E7%AB%A0/","content":"常用控件的使用方法TextView&lt;TextView    android:id=&quot;@+id/text_view&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:gravity=&quot;center&quot;    android:textSize=&quot;24sp&quot;    android:textColor=&quot;#00ff00&quot;    android:text=&quot;This is TextView&quot;/&gt;\n\nandroid:gravity指定文件的对齐方式，可选值有top,bottom,left,right,center等，可以用”|“来同时指定多个值\nandroid:textSize属性指定文字的大小\nandroid:textColor属性指定文字的颜色\nButton&lt;Button    android:id=&quot;@+id/button&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;Button&quot;/&gt;&lt;!--我们在布局文件里设置的文字是&quot;Button&quot;，但最终显示的结果却是&quot;BUTTON&quot;。这是由于系统会对Button中的所有英文字母进行大写转换，如果不是你想要的效果，可以使用如下配置来禁用这一默认特性--&gt;&lt;!-- android:textAllCaps=&quot;false&quot;--&gt;\n\n在MainActivity中为Button的点击事件注册一个监听器\n有出现监听器Toast.makeText不能显示的问题\n\n解决办法\nstep1：进入AVD Manager\nstep2：点击对应虚拟设备顶最右边的倒三角\nstep3：选择Wipe Data后再次启动模拟器\n\nEditText允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理\n&lt;EditText    android:id=&quot;@+id/edit_text&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:hint=&quot;Type Something Here&quot;    android:maxLines=&quot;2&quot;          /&gt;&lt;!--android:hint属性指定了一段提示性的文本--&gt;&lt;!--android:maxLines指定EditText的最大行数--&gt;\n\nImageViewImageView是用于在界面上展示图片的一个控件\n图片通常都是放在以”drawable“开头的目录下，不过由于这个目录没有指定具体的分辨率，所以一般不使用它来放置图片。这里我们在res目录下新建一个drawable-xhdpi目录\n&lt;ImageView    android:id=&quot;@+id/image_View&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:src=&quot;@drawable/bomb&quot;    /&gt;\n\n我感觉有图片大小问题，但是不知道怎么解决。换了个小的就ok啦\nProgressBarProgressBar用于在界面上显示一个进度条，表示我们的程序正在加载一些数据\nAndroid控件的可见属性：所有的Android控件都具有这个属性，可以通过android:visibility进行指定，可选值有3种：visible、invisible、gone。\n\nvisible表示控件是可见的，这个值是默认值，不指定android：visibility时，控件都是见的；\ninvisible表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了；\ngone则表示控件不仅不可见，而且不再占用任何屏幕空间。\n\n使用setVisibility()方法，可以传入View.VISIBLE、View.INVISIBLE和View.GONE 三种值。\n&lt;ProgressBar    android:id=&quot;@+id/progress_bar&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;\n\n我们还可以给ProgressBar指定不同的样式\nAlertDialogAlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶与所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog一般都是用于提示一些非常重要的内容或者警告信息。\n在MainActivity中\nProgressDialogProgressDialog和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心等待。\n4中基本布局线性布局&#x2F;LinearLayout\nandroid:orientation属性指定：vertical，horizontal\n注意：horizontal，内部的控件不能将宽度指定为match_parent；同理vertical，内部的控件不能将高度指定为match_parent\n\nandroid:layout_gravity属性\nandroid:gravity用于指定文字在控件中的对齐方式，\nandroid:layout_gravity用于指定控件在布局中的对齐方式。\nandroid:layout_gravity的可选值和android:gravity差不多，这两个在相对布局都是没用的\n\n但注意：LinearLayout的排列方向是horizontal时，只有垂直方向上的对齐方式才会生效，因为此时水平方向上的长度是不固定的，没添加一个控件，水平方向上的长度都会改变，因而无法指定该放下上的对齐方式；同样的道理，当LinearLayout的排列方向是vertical时，只有水平方向上的对齐方式才会生效。\n\nandroid:layout_weight属性\n这个属性允许我们使用比例的方式来指定控件的大小\n我们使用了android:layout_weight属性，此时控件的宽度就不应该再由android:layout_width来决定，指定成0dp是一种比较规范的写法。\n\n\n相对布局&#x2F;RelativeLayout和LinearLayout的排列规则不同，RelativeLayout显得更加随意一些，它可以通过相对定位的方式让控件出现在布局的任何位置。\n\n相对于父布局进行定位\nandroid:layout _alignParentLeft、android:layout _alignParentTop、android:layout _alignParentRight、android:layout _alignParentBottom、android:layout _centereInParent\ne.g android:layout _alignParentLeft=&quot;true&quot;\n\n相对于控件\nandroid:layout_below、android:layout_above、android:layout_toRightOf、android:layout_toLeftOf\ne.g android:layout_below=&quot;id/button3&quot;\n\n\n帧布局&#x2F;FrameLayout这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角\n用的很少\n介绍碎片\n百分比布局在这种布局中，我们可以不再使用wrap_content、match_parent等方式来指定控件的大小，而是允许直接指定控件在布局中所占的百分比，这样的话就可以轻松实现平分布局甚至是任意比例分割布局的效果。\n由于LinearLayout本身已经支持按比例指定控件的大小了，因此百分比布局只为Frame-Layout和RelativeLayout进行了功能扩展，提供了PercentFrameLayout和PercentRelative这两个全新的布局。\n在项目的build.gradle中添加百分比布局库的依赖，就能保证百分比布局在Android所有系统版本上的兼容性了\n打开app&#x2F;build.gradle文件，在dependencies闭包中添加如下内容：\ncompile &#39;com.android.support:percent:24.2.1&#39;\n一些补充在不同的布局中layout_gravity和gravity是否有区别在相对布局中layout_gravity和gravity不起任何作用\ngravity在线性布局中不起任何作用，layout_gravity在线性布局中起作用\n当我们使用 android:orientation&#x3D;“vertical” 时， android:layout_gravity只有水平方向的设置才起作用，垂直方向的设置不起作用。即：left，right，center_horizontal 是生效的\n当我们使用android:orientation&#x3D;“horizontal” 时， android:layout_gravity只有垂直方向的设置才起作用，水平方向的设置不起作用。即：top，bottom，center_vertical 是生效的\n属性src和background的区别1.background根据ImageView组件给定的长宽进行拉伸，而src就存放的是原图的大小，不会进行拉伸。src是图片内容（前景），background是背景，二者可以同时使用。\nImageButton 是带图标的Button控件，有src的属性，也就是设置他的图标，也有一个所有控件公有的属性background， 这个也可以设置它的“图标”。\n其实，src才是设置图标，而background只是设置背景。\n重要的是，background是底层的图片资源，src是覆盖在background上面的资源，他们可以叠加使用，实现选中的效果。在ActivityGroup用到。\n\n2.scaleType只对src起作用；background可设置透明度，比如在ImageButton中就可以用android:scaleType控制图片的缩放方式。\nFIT_XY：对原图宽高进行放缩，该放缩不保持原比例来填充满ImageView。\nMATRIX：不改变原图大小从ImageView的左上角开始绘制，超过ImageView部分不再显示。\nCENTER：对原图居中显示，超过ImageView部分不再显示。\nCENTER_CROP：对原图居中显示后进行等比放缩处理，使原图最小边等于ImageView的相应边。\nCENTER_INSIDE：若原图宽高小于ImageView宽高，这原图不做处理居中显示，否则按比例放缩原图宽(高)是之等于ImageView的宽(高)。\nFIT_START：对原图按比例放缩使之等于ImageView的宽高，若原图高大于宽则左对齐否则上对其。\nFIT_CENTER：对原图按比例放缩使之等于ImageView的宽高使之居中显示。\nFIT_END：对原图按比例放缩使之等于ImageView的宽高，若原图高大于宽则右对齐否则下对其。\n\n线性布局中如果有两个及以上的控件，需要加一个属性才不会报错\n&#x2F;&#x2F;垂直排列android:orientation&#x3D;”vertical”&#x2F;&#x2F;水平排列android:orientation&#x3D;”horizontal”\n\nlayout_weight属性的用法和意义意义：layout_weight属性的意义就是将父控件的剩余空间按照设置的权重比例再分配，也就是在布局的时候，系统先按照view的layout_width和layout_height来布局，然后再根据layout_weight对view的位置进行调整。\nlayout_weight默认为0\n1.额外空间，指的是剩余空闲空间, 额外空间将在权重大于0的所有视图中按比例分配。如下，总权重为1+1&#x3D;2\n第一个控件是比第二个控件占的空间小的，即w(12345)+1&#x2F;2空闲空间&lt; w(123456)+1&#x2F;2控件\n&lt;LinearLayout   android:orientation=&quot;horizontal&quot;&gt;  &lt;TextView     android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_height&quot;    android:layout_weight=&quot;1&quot;    android:text=&quot;12345&quot;/&gt;  &lt;TextView     android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_height&quot;    android:layout_weight=&quot;1&quot;    android:text=&quot;123456&quot;/&gt; &lt;/LinearLayout&gt;\n\n 如果我们让控件的宽度定义为layout_width&#x3D;”0dp” ，这样比如2个控件的 layout_weight&#x3D;”1” 就可以各自50%平分整个空间了，因为：0 + 1&#x2F;2空闲空间 &#x3D; 0 + 1&#x2F;2空闲空间。\n2.默认layout_weight为0，所以如果这么写：&lt;LinearLayout    android:orientation=&quot;horizontal&quot;&gt;   &lt;TextView     android:layout_width=&quot;40dp&quot;     android:layout_height=&quot;match_parent&quot;     android:background=&quot;#000&quot; /&gt;   &lt;Button     android:layout_width=&quot;0dp&quot;     android:layout_height=&quot;match_parent&quot;     android:layout_weight=&quot;1&quot;/&gt;   &lt;TextView     android:layout_width=&quot;40dp&quot;     android:layout_height=&quot;match_parent&quot;     android:background=&quot;#888&quot; /&gt; &lt;/LinearLayout&gt;\n\n 则总权重为1，即Button占了所有剩余空闲空间，无论它在哪个位置\n3.在排列方向上设置了match_parent, 如下，权重为2，1，2&lt;LinearLayout    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:orientation=&quot;horizontal&quot;&gt;    &lt;Button      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;wrap_content&quot;       android:text=&quot;1&quot;      android:layout_weight=&quot;2&quot;/&gt;    &lt;Button      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;wrap_content&quot;      android:text=&quot;2&quot;      android:layout_weight=&quot;1&quot;/&gt;    &lt;Button      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;wrap_content&quot;      android:text=&quot;3&quot;      android:layout_weight=&quot;2&quot;/&gt;&lt;/LinearLayout&gt;\n\n 运行结果如下:\n\n分析：因为设置的都是match_parent，所以如果没有设置权重，三个Button只会显示第一个,其他会被覆盖，但是设置了权重后， 我们就按三个Button给定的width&#x3D;match_parent计算剩余空间\n剩余空间&#x3D;1个match_parent空间-3个match_parent空间&#x3D; -2个match_parent空间（负2）\n所以\nButton1所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*2&#x2F;5 &#x3D; 1&#x2F;5个match_parent空间\nButton2所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*1&#x2F;5 &#x3D; 3&#x2F;5个match_parent空间\nButton3所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*2&#x2F;5 &#x3D; 1&#x2F;5个match_parent空间\n所以在统一设置match_parent时，会有这么一个特性，权重越大，空间越小。\n4.在某个控件权重刚好为另外的所有控件权重之和时，这个控件会消失。如权重变为1，2，3\n&lt;LinearLayout      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;match_parent&quot;      android:orientation=&quot;horizontal&quot;&gt;      &lt;Button          android:layout_width=&quot;match_parent&quot;          android:layout_height=&quot;wrap_content&quot;           android:text=&quot;1&quot;          android:layout_weight=&quot;1&quot;/&gt;      &lt;Button          android:layout_width=&quot;match_parent&quot;          android:layout_height=&quot;wrap_content&quot;          android:text=&quot;2&quot;          android:layout_weight=&quot;2&quot;/&gt;      &lt;Button          android:layout_width=&quot;match_parent&quot;          android:layout_height=&quot;wrap_content&quot;          android:text=&quot;3&quot;          android:layout_weight=&quot;3&quot;/&gt;&lt;/LinearLayout&gt;\n\n运行结果如下:\n\n同样的算法：\nButton1所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*1&#x2F;6 &#x3D; 2&#x2F;3个match_parent空间\nButton2所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*2&#x2F;6 &#x3D; 1&#x2F;3个match_parent空间\nButton3所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*3&#x2F;6 &#x3D; 0个match_parent空间\n剩余布局大小 &#x3D; 父布局大小 - 子布局大小之和\n获取输入框的内容(用Button和EditText实现)1.获取button和editText的实例\n2.在点击事件中用String获取editText的内容\n3.用Toast打印出来\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;    private EditText editText;    @Override    protected void oncreate( Bundle savedInstanceState) &#123;        super.onCreate( savedInstanceState) ;        setContentview (R.layout.activity_main) ;        Button button = (Button) findViewById(R.id.button) ;        editText = (EditText)findViewById(R.id.edit_text);        button.setOnclickListener(this) ;    &#125;    @Override    public void onclick(View v) &#123;        switch (v.getId()) &#123;        case R.id.button:            String inputText = editText.getText().toString();               Toast.makeText(MainActivity.this,inputText,Toast.LENGTH_SHORT).show();            break;        default:            break;        &#125;    &#125;&#125;\n\nListViewLIstView最主要的内容其实就是适配器\n常用数据适配器\n数据适配器是数据与视图之间的桥梁，它类似于一个转换器，将复杂的数据转换成用户可以接受的方式进行呈现\n\n常用的数据适配器\n\nBaseAdapter\nSimpleAdapter\nArrayAdapter\n\n\n\n","categories":["android学习"],"tags":["android"]},{"title":"Android 第二章","url":"/2022/05/17/android-%E7%AC%AC%E4%BA%8C%E7%AB%A0/","content":"基本活动android:exported android:exported是Android中的四大组件 Activity，Service，Provider，Receiver 四大组件中都会有的一个属性。\n\nActivity中\n&lt;activity          ……          android:exported=[&quot;true&quot; | &quot;false&quot;]          ……/&gt;\n\n在Activity中该属性用来标示：当前Activity是否可以被另一个Application的组件启动：true允许被启动；false不允许被启动。\n如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。\nexported 的默认值根据Activity中是否有intent filter 来定。没有任何的filter意味着这个Activity只有在详细的描述了他的class name后才能被唤醒 .这意味着这个Activity只能在应用内部使用，因为其它application并不知道这个class的存在。所以在这种情况下，它的默认值是false。从另一方面讲，如果Activity里面至少有一个filter的话，意味着这个Activity可以被其它应用从外部唤起，这个时候它的默认值是true。\n\n\n在活动中使用ToastToast提醒，将短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间\nprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.first_layout);    Button button1 = (Button) findViewById(R.id.button_1);    button1.setOnClickListener(new View.OnClickListener() &#123;    @Override    public void onClick(View view) &#123;        Toast.makeText(FirstActivity.this,&quot;You clicked Button 1&quot;,Toast.LENGTH_SHORT).show();    &#125;&#125;);&#125;\n\n写法好像变了\n@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.first_layout);    Button button1 = (Button) findViewById(R.id.button_1);    button1.setOnClickListener(            view -&gt; Toast.makeText(FirstActivity.this,&quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show());&#125;\n\n在活动中使用Menu我们可以使用 、、 三种XML元素定义 Menu，下面简单介绍一下它们：\n\n是菜单项的容器\n- 元素必须是该文件的根节点，并且能够包含一个或多个和元素\n是菜单项，用于定义MenuItem，可以嵌套元素，以便创建子菜单\n是元素的不可见容器（可选）\n可以使用它对菜单项进行分组，使一组菜单项共享可用性和可见性等属性。\n\n\n\n　　其中，是我们主要需要关注的元素，它的常见属性如下：\n\nandroid:id：菜单项(MenuItem)的唯一标识\nandroid:icon：菜单项的图标（可选）\nandroid:title：菜单项的标题（必选）\nandroid:showAsAction：指定菜单项的显示方式\n常用的有ifRoom、never、always、withText\n多个属性值之间可以使用|隔开\n\n\n\n使用menures&#x2F;menu&#x2F;main.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item        android:id=&quot;@+id/add_item&quot;        android:title=&quot;@string/Add&quot;/&gt;    &lt;item        android:id=&quot;@+id/remove_item&quot;        android:title=&quot;@string/Remove&quot;/&gt;&lt;/menu&gt;\n\nFirstActivity.java\n@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123;    getMenuInflater().inflate(R.menu.main,menu);    return true;&#125;@SuppressLint(&quot;NonConstantResourceId&quot;)@Overridepublic boolean onOptionsItemSelected(@NonNull MenuItem item) &#123;    switch (item.getItemId())&#123;        case R.id.add_item:            Toast.makeText(this,&quot;You clicked add&quot;,Toast.LENGTH_SHORT).show();            break;        case R.id.remove_item:            Toast.makeText(this,&quot;You clicked Remove&quot;,Toast.LENGTH_SHORT).show();            break;        default:    &#125;    return true;&#125;\n\n使用Intent在活动之间穿梭Intent大致可以分为两种：显式Intent和隐式Intent\n显式与隐式的跳转","categories":["android学习"],"tags":["android"]},{"title":"Android 第五章","url":"/2022/08/09/android-%E7%AC%AC%E4%BA%94%E7%AB%A0/","content":"详解广播机制1、广播机制简介Android提供了一套完整的api，允许应用程序自由地发送和接收广播\n接收广播的方法需要引入一个新的概念——广播接收器（Broadcast Receiver）\n在Android开发中，BroadcastReceiver（广播接收器）的应用场景非常多，是一个全局的监听器，属于Android四大组件之一。\n广播类型广播主要可以分为两种类型：标准广播和有序广播\n\n标准广播\n标准广播（Normal broadcasts）是一种完全异步执行的广播。在广播发送后，所有的广播接收器都可以在同一时刻接收到这条广播信息，然后各自进行相应的逻辑处理。标准广播的优点是效率高，但与此同时，也意味着标准广播是无法被截断的，所有的广播接收器都可以接收到。标准广播示意图如下：\n\n\n有序广播\n有序广播（Ordered broadcasts）是一种同步执行的广播。在广播发出后，同一时间只能有一个优先级最高的广播接收器来接收。在优先级高的广播接收器接收到广播并且执行完内部逻辑后，广播才会继续往优先级低的广播接收器传递，或者优先级高的广播接收器判定广播不需要继续往下传递的时候，则会截断广播，这样后面的广播接收器就不会接收到广播了。有序广播示意图如下：\n\n\n2、广播的作用用于监听&#x2F;接收应用发出的广播消息，并做出相应\n应用场景：\n\na.不同组件之间的通信（应用内、应用间）\nb.与Android系统在特定情况下的通信，Android内置了许多系统级别的广播接收器，如更换系统语言、电池电量变化等都会发出相应的广播。如果我们希望在自己的应用中可以接收到这些广播，就需要注册对应的广播接收器。\nc.多线程通信\n\n3、接收系统广播广播接收器可以自由地对自己感兴趣的广播进行注册，这样当有相应的广播发出时，广播接收器就能够收到该广播，并在内部处理相应的逻辑。\n广播接收器的注册有两种方式：动态注册和静态注册。\n\n动态注册就是在代码中注册，当你需要用到广播接收器的时候直接在代码中注册；\n而静态注册则是在AndroidManifest.xml文件中进行注册。\n\n动态注册监听网络变化动态注册广播接收器只需要创建一个继承BroadcastReceiver的类，并且重写父类onReceive()方法即可。当广播接收器接收到相应广播时，就会执行onReceive()方法。\n以注册一个监听网络状态变化的广播接收器做例子\n首先，Android系统为了保护用户的安全和隐私，对App申请敏感权限有着严格的规定，必须在配置文件中声明权限，否则会导致App的报错。而我们需要访问系统的网络状态也属于敏感权限，是需要声明权限的。\n打开AndroidManifest.xml文件，在标签里加入以下代码即可：\n&lt;uses-permission android:name=”android.permission.ACCESS_NETWORK_STATE” /&gt;\n然后到注册广播接收器：\npublic class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        IntentFilter filter = new IntentFilter();        //设置接收广播类型        filter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);        NetworkStateReceiver networkStateReceiver = new NetworkStateReceiver();        //调用Context的registerReceiver()方法进行动态注册        registerReceiver(networkStateReceiver, filter);    &#125;        @Override    protected void onDestroy() &#123;        super.onDestroy();        //在注册完广播接收器之后记得在对应的生命周期中注销广播接收器        unregisterReceiver(networkStateReceiver);    &#125;    class NetworkStateReceiver extends BroadcastReceiver &#123;        @Override        public void onReceive(Context context, Intent intent)&#123;        //判断网络状态        ConnectivityManager connectionManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);        NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo();        if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123;            Toast.makeText(context, &quot;network is available&quot;, Toast.LENGTH_SHORT).show();        &#125; else &#123;            Toast.makeText(context, &quot;network is unavailable&quot;, Toast.LENGTH_SHORT).show();          &#125;        &#125;    &#125;&#125;\n\n在onReceive()方法中，首先通过getSystemService()方法得到了ConnectivityManager的实例，这是一个系统服务类，专门用于管理网络连接，然后调用它的getActiveNetworkInfo()方法可以得到NetworkInfo的实例，接着调用NetworkInfo的isAvailable()方法，就可以判断当前是否有网络了。\n需要注意的是，应该养成一个习惯，在注册好广播接收器之后，应该在对应的生命周期中注销广播接收器，如在onCreate()中注册广播接收器，那就应该在onDestroy()中注销广播接收器，onStart()则对应onStop(),onResume()对应onPause()。如果忘记了注销广播接收器可能会导致内存泄漏问题。\n静态注册实现开机启动既然可以动态注册广播接收器了，而且动态注册广播接收器也比较灵活，为什么还需要静态注册广播接收器，特意跑到AndroidManifest.xml中去注册呢？这是因为动态注册广播接收器的缺点：动态注册的广播接收器受组件的生命周期影响，只能在程序启动之后才能接收到广播，注册的逻辑是写在onCreate()方法中的。\n所以当我们需要程序在未启动的情况下接收广播的时候，比如我们希望程序能接收一条开机广播的时候，就需要静态注册广播接收器了。\n下面来创建一个开机启动的广播接收器。\n首先在MainActivity中创建广播接收器：\npublic class BootCompleteReceiver extends BroadcastReceiver &#123;    @Override    public void onReceive(Context context, Intent intent) &#123;        Toast.makeText(context, “BootCompleteReceiver”, Toast.LENGTH_LONG).show();    &#125;&#125;\n\n或者使用Android Studio提供的快捷方式来创建一个广播接收器\n然后在AndroidManifest.xml文件中注册这个广播接收器：\n在标签中添加以下代码：\n&lt;receiver    android:name=”.BootCompleteReceiver”    android:enabled=”true”    android:exported=”true”&gt;    &lt;intent-filter&gt;        &lt;action android:name=”android.intent.action.BOOT_COMPLETED” /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;\n\n其中name属性是MainActivity中继承BroadcastReceiver子类的类名，enabled属性表示是否启用这个广播接收器，exported属性则表示是否允许这个广播接收器接收本程序以外的广播。标签用于指定广播接收器可以接收的广播类型。\n另外，因为监听系统开机广播也需要声明权限，所以还需要在标签内加入权限声明：\n&lt;uses-permission android:name=”android.permission.RECEIVE_BOOT_COMPLETED” /&gt;\n\n这样静态注册广播接收器就完成了。\n\n广播接收器更多的是扮演一种打开程序其他组件的角色，比如创建一条状态栏通知，或者启动一个服务等。\n两种注册方式的区别\n\n\n注册方式\n特点\n应用场景\n\n\n\n静态注册（常驻广播）\n不受组件的生命周期影响（程序关闭后。如果有信息广播来，程序依旧会被系统调用）缺点：耗电、占内存\n需要时刻监听广播（需要在程序还没有启动的时候也需要监听广播时）\n\n\n动态广播（非常驻广播）\n灵活，跟随组件的生命周期变化（组件结束&#x3D;广播结束，在组件结束前需要注销广播接收器）\n只需要在特定时刻监听广播（在程序运行的时候监听广播）\n\n\n4、发送自定义广播广播主要分为 标准广播和有序广播。\n发送标准广播发送标准广播比较简单，只需要在想要发送广播的地方添加以下代码即可：\nIntent intent = new Intent(&quot;android.intent.action.BOOT_COMPLETED&quot;);sendBroadcast(intent);\n\n发送有序广播广播是一种可以跨进程的通信方式，就像前面提到的接收系统网络状态变化的广播，我们应用程序内发送的广播在其他应用也是可以接收到的。\n而有序广播则提供了一个更加灵活的发送广播的方式给我们。\n有序广播的接收器可以通过设定优先级来决定哪个广播接收器先接收广播。优先级的数值越大优先级越高（取值范围-1000~1000），优先级高的广播接收器在接收到广播并进行相应逻辑处理后可将广播传递给下一个优先级高的接收器或者直接截断广播的传递；若优先级相同，那么注册时间较早的广播接收器会优先收到广播。\n由此可见，相对于标准广播，有序广播在灵活性高的同时的效率就比较低了。\n我们安卓手机中一个较为常见的功能：短信拦截，就可以通过有序广播来实现。\n短信拦截原理：系统收到短信的时候，会发出一个有序广播，然后短信拦截程序可以通过设置其本身短信广播接收器的优先级来优先获取到短信，对内容进行识别，若判定为骚扰短信则截断广播的传递。\n\n代码见书p179~183\n\n5、使用本地广播以上说到的标准广播和有序广播都是全局广播，发出的广播任意一个程序都可以接收到，这就很容易导致安全性问题，比如有时候发送的广播携带有关键性数据，有可能会被别的应用程序拦截。\n为了解决全局广播的安全性问题，Android引进了本地广播机制。本地广播发出后只能够在应用程序内部传递，也只有应用程序内部的接收器能接收到本地广播，这样广播的安全性问题就能得到解决了。\n本地广播和全局广播不同的地方在于本地广播主要使用LocalBroadcastManager对广播的发送、注册、注销进行管理。\n下面写一个本地广播的例子：（界面设置一个按钮，点击按钮即可发送本地广播）\npublic class MainActivity extends AppCompatActivity &#123;    private LocalReceiver localReceiver;    private LocalBroadcastManager localBroadcastManager;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button button = (Button) findViewById(R.id.button);        //获取localBroadcastManager实例        localBroadcastManager = LocalBroadcastManager.getInstance(this);        button.setOnClickListener (new View.onClickListener) &#123;            @Override            public void onClick (View v)&#123;                //发送本地广播                Intent intent = new Intent(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);                localBroadcastManager.sendBroadcast(intent);            &#125;        &#125;        //注册本地广播接收器        IntentFilter filter = new IntentFilter(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);        localReceiver = new LocalReceiver();        localBroadcastManager.registerReceiver(localReceiver, filter);        &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        //注销本地广播接收器        localBroadcastManager.unregisterReceiver(localReceiver);    &#125;    public class LocalReceiver extents BroadcastReceiver &#123;        @Override        public void onReceive(Context context, Intent intent) &#123;            Toast.makeText(context, &quot;received in LocalReceiver&quot;, Toast.LENGTH_SHORT),show();        &#125;    &#125;&#125;\n","categories":["android学习"],"tags":["android"]},{"title":"Android 第六章","url":"/2022/08/15/android-%E7%AC%AC%E5%85%AD%E7%AB%A0/","content":"数据存储全方案——详解持久化技术持久化技术简介持久化是指将内存中的瞬时数据保存成永久的数据（存储到存储设备中），保证在设备断电的时候数据仍然不会丢失。Android设备上常用的持久化技术有以下三类：\n\n\n文件存储；\nSharedPreference\n数据库存储\n\n\n文件存储文件储存是Android中最基本的一种数据存储方式\n比较适合用于存储一些简单的文本数据或二进制数据\n核心原理：ontext提供了两个方法来打开数据文件里的文件IO流 FileInputStream openFileInput(String name); FileOutputStream(String name , int mode)，这两个方法第一个参数 用于指定文件名，第二个参数指定打开文件的模式。具体有以下值可选：\nMODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中。\n**MODE_APPEND**：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。\n**MODE_WORLD_READABLE**：表示当前文件可以被其他应用读取；\n**MODE_WORLD_WRITEABLE**：表示当前文件可以被其他应用写入。\n 除此之外，Context还提供了如下几个重要的方法：\ngetDir(String name , int mode):在应用程序的数据文件夹下获取或者创建name对应的子目录\nFile getFilesDir():获取该应用程序的数据文件夹得绝对路径 \nString[] fileList():返回该应用数据文件夹的全部文件\nSharedPreferences存储要想使用SharedPreferences来存储数据，首先需要获取到SharedPreferences对象。Android中主要提供了3种方法用于得到SharedPreferences\n\nContext类中的getSharedPreferences()方法​ 此方法接收两个参数，第一个指定SharedPreferences文件名称，如果指定文件不存在则会创建一个。默认存储在data&#x2F;data&#x2F;&#x2F;shared_prefs目录下。第二个参数指定操作模式，目前只有默认的MODE_PRIVATE可选，，它与直接传0的效果是一样的，表示只有当前的应用程序才能对这个文件读写。其他的如MODE_WORLD_WRITEABLE、MODE_WORLD_READABLE、MODE_MULTI_PROCESS均已被废弃。\n\nActivity类中的getPreferences()方法​ 这个方法和上面的很类似，但只接收一个文件操作模式，因为getPreferences()方法会自动将当前ACtivity的类名作为文件名。\n\nPreferencesManager类中的getDefaultSharedPreferences()方法得到一个SharedPreferences对象后，就可以开始向SharedPreferences文件中存储数据了。主要分为3步：\n\n调用SharedPreferences对象的edit()方法获取一个SharedPreferences.Editor对象然后向这个Editor对象中添加数据，格式是putBoolean()、putString()等等最后调用Editor的apply()方法将数据提交，从而完成数据存储操作。\n\n\n\nSQLite数据库存储Android系统内置了SQLite这款轻量的关系型数据库，占用资源少，通常只需要几百KB的内存就够了。\n创建数据库Android专门提供了一个SQLiteOpenHelper的帮助类用于管理数据库。\nSQLiteOpenHelper是一个抽象类，我们需要创建一个类去继承它，且必须重写两个抽象方法：onCreate()和onUpgrate()。在这两个方法中可以实现创建和升级数据库的逻辑。\nSQLiteOpenHelper中有两个重要的实例方法：getReadableDatabase()和getWritableDatabase()。这两个方法都可以创建或打开一个现有的数据库，并返回一个可对数据库进行读写操作的对象。不同的是，当数据库不可写入的时候，getReadableDatabase()方法返回的对象将以只读的方式打开数据库，而getWritableDatabase()方法将会出现异常。\nSQLiteOpenHelper类中有两个构造函数，这里一般使用参数少一点的那个即可：这个构造函数接收四个参数：第一个是context，第二个是数据库的名称，第三个参数允许我们在查询数据的时候返回一个自定义的Cursor，一般传入null即可，第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作。\n构建出SQLiteOpenHelper的实例后，再调用getReadableDatabase()或getWritableDatabase()就可以创建数据库了，此时重写的onCreate()方法也能得到执行，所以通常在此处处理一些创建表的逻辑。数据库文件会放在&#x2F;data&#x2F;data&#x2F;&#x2F;databases&#x2F;目录下。\nMyDataBaseHelper.java\npackage com.example.myfile;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import android.widget.Toast;public class MyDataBaseHelper extends SQLiteOpenHelper &#123;    public static final String CREATE_BOOK = &quot;create table book (&quot;            + &quot;id integer primary key autoincrement,&quot;            + &quot;author text, &quot;            + &quot;price real, &quot;            + &quot;pages integer,&quot;            + &quot;name text)&quot;;        //String sql=&quot;create table user(id integer primary key autoincrement,username varchar(20),password varchar(20),age integer)&quot;;    private Context mContext;    public MyDataBaseHelper(Context context, String name,                            SQLiteDatabase.CursorFactory factory, int version)&#123;        super(context, name, factory, version);        mContext = context;    &#125;    @Override    public void onCreate(SQLiteDatabase db)&#123;        db.execSQL(CREATE_BOOK);        Toast.makeText(mContext,&quot;created succeeded&quot;, Toast.LENGTH_SHORT).show();    &#125;    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123;    &#125;&#125;\n\nMainActivity.java\n//创建数据库       dbHelper = new MyDataBaseHelper(this,&quot;Bookstore.db&quot;,null,2);       Button createDB =(Button) findViewById(R.id.create_db);       createDB.setOnClickListener(new View.OnClickListener() &#123;           @Override           public void onClick(View view) &#123;               dbHelper.getWritableDatabase();           &#125;       &#125;);\n\n升级数据库MyDataBaseHelper.java\npackage com.example.myfile;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import android.widget.Toast;public class MyDataBaseHelper extends SQLiteOpenHelper &#123;    ...    public static final String CREATE_CATEGORY = &quot;create table Category (&quot;            + &quot;id integer primary key autoincrement,&quot;            + &quot;category_name text, &quot;            + &quot;category_code integer)&quot;;    ...    @Override    public void onCreate(SQLiteDatabase db)&#123;        db.execSQL(CREATE_BOOK);        db.execSQL(CREATE_CATEGORY);        Toast.makeText(mContext,&quot;created succeeded&quot;, Toast.LENGTH_SHORT).show();    &#125;    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123;        db.execSQL(&quot;drop table if exists book&quot;);        db.execSQL(&quot;drop table if exists Category&quot;);        onCreate(db);    &#125;&#125;\n\nMainActivity.java\n//创建数据库        dbHelper = new MyDataBaseHelper(this,&quot;Bookstore.db&quot;,null,2);        Button createDB =(Button) findViewById(R.id.create_db);        createDB.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                dbHelper.getWritableDatabase();            &#125;        &#125;);\n\n添加数据MainActivity.java\nButton addData = (Button) findViewById(R.id.add_data);       addData.setOnClickListener(new View.OnClickListener() &#123;           @Override           public void onClick(View view) &#123;               SQLiteDatabase db = dbHelper.getWritableDatabase();               ContentValues values = new ContentValues();               //开始组装第一条数据               values.put(&quot;name&quot;,&quot;百年孤独&quot;);               values.put(&quot;author&quot;,&quot;加夫列尔·加西亚·马尔克斯&quot;);               values.put(&quot;pages&quot;,666);               values.put(&quot;price&quot;,29.99);               db.insert(&quot;Book&quot;,null,values);               values.clear();               //开始组装第二条数据               values.put(&quot;name&quot;,&quot;骆驼祥子&quot;);               values.put(&quot;author&quot;,&quot;老舍&quot;);               values.put(&quot;pages&quot;,333);               values.put(&quot;price&quot;,28.99);               db.insert(&quot;Book&quot;,null,values);               values.clear();           &#125;       &#125;);\n\n更新数据MainActivity.java\nButton updataData = (Button) findViewById(R.id.update_data);        updataData.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                SQLiteDatabase db = dbHelper.getWritableDatabase();                ContentValues values = new ContentValues();                values.put(&quot;price&quot;,19.99);                db.update(&quot;book&quot;,values,&quot;name = ?&quot;, new String[]&#123;                        &quot;百年孤独&quot;                &#125;);            &#125;        &#125;);\n\n删除数据MainActivity.java\nButton deleteButton = (Button) findViewById(R.id.delete_data);        deleteButton.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                SQLiteDatabase db = dbHelper.getWritableDatabase();                db.delete(&quot;book&quot;,&quot;pages &gt; ?&quot;, new String[]&#123;&quot;300&quot;&#125;);            &#125;        &#125;);\n\n查询数据MainActivity.java\nButton queryButton = (Button) findViewById(R.id.query_data);       queryButton.setOnClickListener(new View.OnClickListener() &#123;           @Override           public void onClick(View view) &#123;               SQLiteDatabase db = dbHelper.getWritableDatabase();               //查询book表中所有数据               Cursor cursor = db.query(&quot;book&quot;,null,null,null,null,null,null);               if (cursor.moveToFirst())&#123;                   do &#123;                       @SuppressLint(&quot;Range&quot;) String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));                       @SuppressLint(&quot;Range&quot;) String author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;));                       @SuppressLint(&quot;Range&quot;) int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;));                       @SuppressLint(&quot;Range&quot;) double price = cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;));                       Log.d(&quot;MainActivity&quot;,&quot;book name is &quot; + name);                       Log.d(&quot;MainActivity&quot;,&quot;book author is &quot; + author);                       Log.d(&quot;MainActivity&quot;,&quot;book pages is &quot; + pages);                       Log.d(&quot;MainActivity&quot;,&quot;book price is &quot; + price);                   &#125;while (cursor.moveToNext());               &#125;           &#125;       &#125;);\n\n使用LitePal操作数据库LitePal是一款开源的Android数据库框架，它采用了对象关系映射（ORM）的模式，并将我们平时开发最常用的一些数据库功能进行了封装，使得不用编写一行SQL语句就可以完成各种建表和增删改查的操作。\n特征\n使用对象关系映射 (ORM) 模式。\n几乎零配置（只有一个配置文件，属性很少）。\n自动维护所有表（例如创建、更改或删除表）。\n支持多数据库。\n用于避免编写 SQL 语句的封装 API。\n很棒的流畅查询 API。\n仍然使用 SQL 的替代选择，但比原始 API更简单、更好。\n\n配置1、添加LitePal库在build.gradle文件添加以下依赖项。\ndependencies &#123;    implementation &#x27;org.litepal.guolindev:core:3.2.3&#x27;&#125;\n\n2、创建 litepal.xml文件在main文件夹中创建assets文件夹，并在assets文件夹中创建一个文件，并将其命名为litepal.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;litepal&gt;    &lt;!--        定义应用程序的数据库名称。        默认情况下，每个数据库名称应以.db结尾。        如果没有将数据库的结尾命名为.db，LitePal会自动为你添加后缀。        例如：        &lt;dbname value=&quot;demo&quot; /&gt;    --&gt;    &lt;dbname value=&quot;Bookstore_2&quot; /&gt;    &lt;!--        定义数据库的版本。每次升级数据库时，版本标签都会有所帮助。        修改你在mapping标签中定义的模型，只需将版本值加上一，数据库的升级将自动进行，无需担心。        例如：        &lt;version value=&quot;1&quot; /&gt;    --&gt;    &lt;version value=&quot;2&quot; /&gt;    &lt;!--        在带有映射标记的列表中定义模型，LitePal将为每个映射类创建表。        模型中定义的受支持字段将映射到列中。        例如：        &lt;list&gt;            &lt;mapping class=&quot;com.test.model.Reader&quot; /&gt;            &lt;mapping class=&quot;com.test.model.Magazine&quot; /&gt;        &lt;/list&gt;    --&gt;    &lt;list&gt;&lt;!--        &lt;mapping class=&quot;com.test.model.NewFriend&quot; /&gt;--&gt;        &lt;mapping class=&quot;com.example.myfile.Book&quot;&gt;&lt;/mapping&gt;        &lt;mapping class=&quot;com.example.myfile.Category&quot;&gt;&lt;/mapping&gt;    &lt;/list&gt;    &lt;!--        定义.db文件应位于的位置。        “internal”是指.db文件将存储在任何人都无法访问的internal storage的数据库文件夹中。        “external”是指.db文件将存储在主外部存储设备上的目录路径中，应用程序可以将其拥有的所有人都可以访问的持久文件放置在该目录中。        “internal”将作为默认值。        例如：        &lt;storage value=&quot;external&quot; /&gt;    --&gt;&lt;/litepal&gt;\n\n\ndbname：配置项目的数据库名称。\nversion：配置数据库的版本。每次要升级数据库，加这里的值。\nlist：配置映射类。\nstorage：配置应该存储数据库文件的位置。internal和external是唯一有效的选项\n\n3、配置 LitePalApplication为了使 API 变得简单，只需在AndroidManifest.xml 中配置 LitePalApplication如下：\n&lt;manifest&gt;    &lt;application        android:name=&quot;org.litepal.LitePalApplication&quot;        ...    &gt;        ...    &lt;/application&gt;&lt;/manifest&gt;\n\n使用创建类Book\npackage com.example.myfile;import org.litepal.crud.LitePalSupport;public class Book extends LitePalSupport &#123;    private int id;    private String author;    private double price;    private int pages;    private String name;    private String press;    public int getId()&#123;        return id;    &#125;    public void setId(int id)&#123;        this.id=id;    &#125;    public String getAuthor()&#123;        return author;    &#125;    public void setAuthor(String author)&#123;        this.author=author;    &#125;    public double getPrice()&#123;        return price;    &#125;    public void setPrice(double price)&#123;        this.price=price;    &#125;    public int getPages()&#123;        return pages;    &#125;    public void setPages(int pages)&#123;        this.pages=pages;    &#125;    public String getName()&#123;        return name;    &#125;    public void setName(String name)&#123;        this.name=name;    &#125;&#125;\n\n同时修改litepal.xml \n&lt;list&gt;&lt;!--        &lt;mapping class=&quot;com.test.model.NewFriend&quot; /&gt;--&gt;        &lt;mapping class=&quot;com.example.myfile.Book&quot;&gt;&lt;/mapping&gt; &lt;/list&gt;\n\n修改MainActivity.java\npublic class MainActivity extends AppCompatActivity &#123;    private MyDataBaseHelper dbHelper;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //创建表        Button createDatabase = (Button) findViewById(R.id.create_db);        createDatabase.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                LitePal.getDatabase();            &#125;        &#125;);        //添加数据        Button addDate = (Button) findViewById(R.id.add_data);        addDate.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                Book book = new Book();                book.setName(&quot;百年孤独&quot;);                book.setAuthor(&quot;加夫列尔·加西亚·马尔克斯&quot;);                book.setPages(666);                book.setPrice(29.99);                book.setPress(&quot;Unknown&quot;);                book.save();            &#125;        &#125;);        //修改数据        Button updateData = (Button) findViewById(R.id.update_data);        updateData.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                Book book = new Book();                book.setName(&quot;骆驼祥子&quot;);                book.setAuthor(&quot;老舍&quot;);                book.setPages(333);                book.setPrice(27.99);                book.setPress(&quot;Unknown&quot;);                book.save();//                book.setPrice(17.99);//                book.save();                book.setPrice(18.89);                book.setPress(&quot;ZHOU&quot;);                book.updateAll(&quot;name = ? and author = ?&quot;, &quot;骆驼祥子&quot;,&quot;老舍&quot;);            &#125;        &#125;);        //删除数据        Button deleteButton = (Button) findViewById(R.id.delete_data);        deleteButton.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                LitePal.deleteAll(Book.class,&quot;price&lt; ?&quot; ,&quot;20&quot;);            &#125;        &#125;);        //查询数据        Button queryButton = (Button) findViewById(R.id.query_data);        queryButton.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View view) &#123;                List&lt;Book&gt; books = LitePal.findAll(Book.class);                for (Book book: books)&#123;                    Log.d(&quot;MainActivity&quot;,&quot;book name is &quot; + book.getName());                    Log.d(&quot;MainActivity&quot;,&quot;book author is &quot; + book.getAuthor());                    Log.d(&quot;MainActivity&quot;,&quot;book pages is &quot; + book.getPages());                    Log.d(&quot;MainActivity&quot;,&quot;book price is &quot; + book.getPrice());                    Log.d(&quot;MainActivity&quot;,&quot;book price is &quot; + book.getPress());                    /*                    List&lt;Book&gt; books = LitePal.select(&quot;name&quot;, &quot;author&quot;).find(Book.class);                    select()                    where()                    order()                    limit()                    offset()                     */                &#125;            &#125;        &#125;);    &#125;&#125;    &#125;);\n\n\n","categories":["android学习"],"tags":["android"]},{"title":"Android 第四章","url":"/2022/07/26/android-%E7%AC%AC%E5%9B%9B%E7%AB%A0/","content":"1、碎片（Fragment）碎片是一种可以嵌入在活动当中的UI片段，它能让程序更加合理和充分地利用大屏幕的空间，因而在平板上应用得非常广泛。\n\n碎片拥有自己的布局，自己的行为及自己的生命周期回调。\n当活动在运行的时候，你可以在活动中添加或者移除碎片。\n你可以合并多个碎片在一个单一的活动中来构建多栏的UI。\n碎片可以被用在多个活动中。\n碎片的生命周期和它的宿主活动紧密关联。这意味着活动被暂停，所有活动中的碎片被停止。\n碎片可以实现行为而没有用户界面组件。\n碎片是 Android API 版本11中被加入到 Android API。\n\n通过继承 Fragment 类来创建碎片。可以通过使用 元素在活动的布局文件中声明碎片来在你的活动中插入碎片。\n在引入碎片之前，由于每次给定的一个时间点在屏幕上只能显示单一的活动，因此我们有一个局限。我们无法分割设备屏幕并且独立的控制不同的部分。伴随着碎片的引入，我们获得了更大的灵活性，并使得一个时间点只能在屏幕上有一个单一活动的限制被移除。现在我们可以有单一的活动，但每个活动由多个碎片组装，每个碎片有自己的布局，事件和完整的生命周期。\n下面是一个典型的示例演示如何让两个由碎片定义的UI模块，在为平板设计的活动中组合，在为手持设备设计的活动中分离。\n\n当运行在在平板尺寸的设备上，这个应用程序可以在活动A中嵌入两个碎片。在手机设备屏幕上，由于没有足够的空间，活动A仅包含有文章列表的碎片，当用户点击文章时，启动包含第二个碎片的活动B来阅读文章。\n碎片的生命周期Android 的碎片拥有自己的生命周期，与 Android 的活动很相似。下面简单介绍它生命周期的不同阶段。\n\n这是在类fragment中你可以重写的方法列表：\n\nonAttach(): 碎片实例被关联到活动实例。碎片和活动还没有完全初始化。通常，你在该方法中获取到活动的引用，在碎片将来的初始化工作中被使用。\nonCreate(): 当创建碎片时，系统调用该方法。你需要初始化一些碎片的必要组件。这些组件是当碎片被暂停、停止时需要保留的，以便被恢复。\nonCreateView(): 当碎片将要第一次绘制它的用户界面时系统调用该方法。为了绘制碎片的UI，你需要从该方法中返回一个代表碎片根布局的View组件。如果该碎片不提供用户界面，直接返回null。\nonActivityCreated: 当宿主活动被创建，在onCreateView()方法之后调用该方法。活动和碎片实例与活动的视图层级被创建。这时，视图可以通过findViewById()方法来访问。在这个方法中，你可以实例化需要Context对象的对象。\nonStart(): 碎片可见时调用该方法。\nonResume(): 碎片可交互时调用该方法。\nonPause(): 当首次表明用户将要离开碎片时系统调用该方法。通常，这里你需要提交任何的会超出用户会话的持久化的变化。\nonStop(): 碎片将要被停止时调用。\nonDestroyView(): 调用该方法后，碎片将要被销毁。\nonDestroy(): 该方法被用来清理碎片的状态。但在Android平台并不保证一定被调用。\n\n体验碎片的生命周期package com.example.myapplication;import android.content.Context;import android.os.Bundle;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import androidx.fragment.app.Fragment;public class RightFragment extends Fragment &#123;    public static final String TAG = &quot;哦右边的碎片&quot;;    @Override    public void onAttach(Context context)&#123;        super.onAttach(context);        Log.d(TAG,&quot;onAttach&quot;);    &#125;    @Override    public void onCreate(Bundle savedInstanceState)&#123;        super.onCreate(savedInstanceState);        Log.d(TAG,&quot;onCreate&quot;);    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)&#123;        Log.d(TAG,&quot;onCreateView&quot;);        View view = inflater.inflate(R.layout.right_fragment,container,false );        return view;    &#125;    @Override    public void onActivityCreated(Bundle savedInstanceState)&#123;        super.onActivityCreated(savedInstanceState);        Log.d(TAG,&quot;onActivityCreated&quot;);    &#125;    @Override    public void onStart()&#123;        super.onStart();        Log.d(TAG,&quot;onStart&quot;);    &#125;    @Override    public void onResume()&#123;        super.onResume();        Log.d(TAG,&quot;onResume&quot;);    &#125;    @Override    public void onPause()&#123;        super.onPause();        Log.d(TAG,&quot;onPause&quot;);    &#125;    @Override    public void onStop()&#123;        super.onStop();        Log.d(TAG,&quot;onStop&quot;);    &#125;    @Override    public void onDestroyView()&#123;        super.onDestroyView();        Log.d(TAG,&quot;onDestroyView&quot;);    &#125;    @Override    public void onDestroy()&#123;        super.onDestroy();        Log.d(TAG,&quot;onDestroy&quot;);    &#125;    @Override    public void onDetach()&#123;        super.onDetach();        Log.d(TAG,&quot;onDetach&quot;);    &#125;&#125;\n\n碎片类型基本的碎片可以分为如下所示的三种：\n\n单帧碎片 - 单帧碎片被如移动电话之类的手持设备使用。一个碎片如同一个视频一样显示。\n列表碎片 - 包含有特殊列表视图的碎片被叫做列表碎片。\n碎片过渡 - 与碎片事务一起使用。可以从一个碎片移动到另外一个碎片。\n\n2、动态加载布局的技巧限定符（Qualofiers）activity_main.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;fragment        android:id=&quot;@+id/left_fragment&quot;        android:name=&quot;com.example.myapplication.LeftFragment&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_weight=&quot;1&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;\n\nlarge/activity_main.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;fragment        android:id=&quot;@+id/left_fragment&quot;        android:name=&quot;com.example.myapplication.LeftFragment&quot;        android:layout_width=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:layout_height=&quot;match_parent&quot;/&gt;    &lt;fragment        android:id=&quot;@+id/right_fragment&quot;        android:name=&quot;com.example.myapplication.RightFragment&quot;        android:layout_width=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;!--    layout/activity_main布局只包含一个碎片，即单页模式，而layout-large/activity_main布局包含了两个碎片，即双页模式。--&gt;&lt;!--    其中large就是一个限定符，那些屏幕被认为是large的设备就会自动加载layout-large文件夹下的布局文件，而小屏幕的设备则还是会加载layout文件夹下的布局。--&gt;&lt;/LinearLayout&gt;\n\n为了适配不同屏幕大小的android手机或android平板，有时候就需要利用限定符来为不同的屏幕设定不同的布局文件。 android中一些常用的限定符如下所示：\n\n\n\n屏幕特性\n限定符\n描述\n\n\n\n屏幕尺寸\nsmall\n小屏幕\n\n\n\nnormal\n基准屏幕\n\n\n\nlarge\n大屏幕\n\n\n\nxlarge\n超大屏幕\n\n\n屏幕密度\nldpi\n&lt;&#x3D;120dpi(低分辨率设备)\n\n\n\nmdpi\n&lt;&#x3D; 160dpi(中等分辨率设备)\n\n\n\nhdpi\n&lt;&#x3D; 240dpi(高分辨率设备)\n\n\n\nxhdpi\n&lt;&#x3D; 320dpi(超高分辨率设备)\n\n\n\nxxhdpi\n&lt;&#x3D; 480dpi(超超高分辨率设备)\n\n\n\nxxhdpi\n&lt;&#x3D; 640dpi(只用来存放icon)\n\n\n\nnodpi\n与屏幕密度无关的资源.系统不会针对屏幕密度对其中资源进行压缩或者拉伸\n\n\n\ntvdpi\n介于mdpi与hdpi之间,特定针对213dpi,专门为电视准备的,手机应用开发不需要关心这个密度值.\n\n\n屏幕方向\nland\n横向\n\n\n\nport\n纵向\n\n\n屏幕宽高比\nlong\n比标准屏幕宽高比明显的高或者宽的这样屏幕\n\n\n\nnotlong\n和标准屏幕配置一样的屏幕宽高比\n\n\n3、FragmentManager从字面意思来看, FragmentManager 就是 Fragment 的管理类, 点开源码可以看到也确实是这样, Fragment 的生命周期就是通过 FragmentManager 来管理的. \n查看源码可以看到 FragmentManager是一个抽象类, 它的实现类是 FragmentManagerImpl 类。\n和Activity的关联关系在 FragmentActivity 内部有这样一行代码:\nfinal FragmentController mFragments = FragmentController.createController(new HostCallbacks());\n\n并且我们也可以得出这样的结论:\n一个 Activity 只对应一个 FragmentManager 对象\n","categories":["android学习"],"tags":["android"]},{"title":"信息安全","url":"/2022/05/18/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/","content":"信息安全Robots\n搜索引擎使用spider程序自动访问互联网上的网页并获取网页信息。spider在访问一个网站时，会首先会检查该网站的根域下是否有一个叫做robots.txt的纯文本文件。您可以在您的网站中创建一个纯文本文件robots.txt，在文件中声明该网站中不想被robot访问的部分或者指定搜索引擎只收录特定的部分。\nrobots.txt 放置位置\nrobots.txt文件应该放置在网站根目录下。举例来说，当spider访问一个网站(比如http://www.ubangmang.com)时，首先会检查该网站中是否存在http://www.ubangmang.com/robots.txt这个文件，如果 Spider找到这个文件，它就会根据这个文件的内容，来确定它访问权限的范围。\nrobots.txt 格式\nUser-agent:\n该项的值用于描述搜索引擎robot的名字。如果该项的值设为*，则对任何robot均有效，在”robots.txt”文件中，”User-agent:*”这样的记录只能有一条\n Disallow: 该项的值用于描述不希望被访问的一组URL，这个值可以是一条完整的路径，也可以是路径的非空前缀，以Disallow项的值开头的URL不会被robot访问。\n例 如”Disallow: &#x2F;help”禁止robot访问&#x2F;help*.html、&#x2F;help&#x2F;index.html， 而”Disallow: &#x2F;help&#x2F;”则允许robot访问&#x2F;help*.html，不能访问&#x2F;help&#x2F;index.html。\n允许robot访问该网站的所有url，在”&#x2F;robots.txt”文件中，至少要有一条Disallow记录。如果”&#x2F;robots.txt”不存在或者为空文件，则对于所有的搜索引擎robot，该网站都是开放的。\nAllow:\n该项的值用于描述希望被访问的一组URL，与Disallow项相似\n特别注意的是Disallow与Allow行的顺序是有意义的，robot会根据第一个匹配成功的 Allow或Disallow行确定是否访问某个URL\nerxff和referer\n关于xff和referer维基百科：\nX-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。\nXXF的格式：\nX-Forwarded-For: 本机IP, 代理1IP, 代理2IP, 代理2IP\n其中\nreferer（来源） 是http的拓展头部，作用是记录当前请求页面的来源页面的地址。\n（网页1中有个链接，你点链接，弹出网页2\n此时你抓网页2的包，会看到\nreferer：网页1）\nReferer的作用1.防盗链。\n设置网页对请求的判断，\n访问网页2，想要我本人从网页2下载某些数据，不想让别人下载\n那我就拥有个私人网页1，没有公开，我从网页1访问网页2\n网页2一看请求的Referer：我靠，是网页!!!!!顶级VVVIP，惹不得，他要啥给啥\n如果不是，权限一个都没有\n这是不是就达到防盗链的效果了？\n2.防止恶意请求。\n比如我的网站上，静态请求是*.html结尾的，动态请求是*.shtml，那么由此可以这么用，所有的*.shtml请求，必须 Referer 为我自己的网站。\n\n参考：\n[1]: https://blog.csdn.net/weixin_43639682/article/details/113879449\t“引用一”[2]: https://blog.csdn.net/slj1552560/article/details/113825428\t“引用二”\n\n","tags":["CTF","信息安全"]},{"title":"Hello World","url":"/2022/05/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]