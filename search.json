[{"title":"Android 第一章","url":"/2022/05/15/android-%E7%AC%AC%E4%B8%80%E7%AB%A0/","content":"Android的安装Android项目的建立log日志的使用","categories":["Android学习"],"tags":["Android"]},{"title":"Android 第四章","url":"/2022/07/26/android-%E7%AC%AC%E5%9B%9B%E7%AB%A0/","content":"1、碎片（Fragment）碎片是一种可以嵌入在活动当中的UI片段，它能让程序更加合理和充分地利用大屏幕的空间，因而在平板上应用得非常广泛。\n\n碎片拥有自己的布局，自己的行为及自己的生命周期回调。\n当活动在运行的时候，你可以在活动中添加或者移除碎片。\n你可以合并多个碎片在一个单一的活动中来构建多栏的UI。\n碎片可以被用在多个活动中。\n碎片的生命周期和它的宿主活动紧密关联。这意味着活动被暂停，所有活动中的碎片被停止。\n碎片可以实现行为而没有用户界面组件。\n碎片是 Android API 版本11中被加入到 Android API。\n\n通过继承 Fragment 类来创建碎片。可以通过使用 元素在活动的布局文件中声明碎片来在你的活动中插入碎片。\n在引入碎片之前，由于每次给定的一个时间点在屏幕上只能显示单一的活动，因此我们有一个局限。我们无法分割设备屏幕并且独立的控制不同的部分。伴随着碎片的引入，我们获得了更大的灵活性，并使得一个时间点只能在屏幕上有一个单一活动的限制被移除。现在我们可以有单一的活动，但每个活动由多个碎片组装，每个碎片有自己的布局，事件和完整的生命周期。\n下面是一个典型的示例演示如何让两个由碎片定义的UI模块，在为平板设计的活动中组合，在为手持设备设计的活动中分离。\n\n当运行在在平板尺寸的设备上，这个应用程序可以在活动A中嵌入两个碎片。在手机设备屏幕上，由于没有足够的空间，活动A仅包含有文章列表的碎片，当用户点击文章时，启动包含第二个碎片的活动B来阅读文章。\n碎片的生命周期Android 的碎片拥有自己的生命周期，与 Android 的活动很相似。下面简单介绍它生命周期的不同阶段。\n\n这是在类fragment中你可以重写的方法列表：\n\nonAttach(): 碎片实例被关联到活动实例。碎片和活动还没有完全初始化。通常，你在该方法中获取到活动的引用，在碎片将来的初始化工作中被使用。\nonCreate(): 当创建碎片时，系统调用该方法。你需要初始化一些碎片的必要组件。这些组件是当碎片被暂停、停止时需要保留的，以便被恢复。\nonCreateView(): 当碎片将要第一次绘制它的用户界面时系统调用该方法。为了绘制碎片的UI，你需要从该方法中返回一个代表碎片根布局的View组件。如果该碎片不提供用户界面，直接返回null。\nonActivityCreated: 当宿主活动被创建，在onCreateView()方法之后调用该方法。活动和碎片实例与活动的视图层级被创建。这时，视图可以通过findViewById()方法来访问。在这个方法中，你可以实例化需要Context对象的对象。\nonStart(): 碎片可见时调用该方法。\nonResume(): 碎片可交互时调用该方法。\nonPause(): 当首次表明用户将要离开碎片时系统调用该方法。通常，这里你需要提交任何的会超出用户会话的持久化的变化。\nonStop(): 碎片将要被停止时调用。\nonDestroyView(): 调用该方法后，碎片将要被销毁。\nonDestroy(): 该方法被用来清理碎片的状态。但在Android平台并不保证一定被调用。\n\n体验碎片的生命周期package com.example.myapplication;import android.content.Context;import android.os.Bundle;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import androidx.fragment.app.Fragment;public class RightFragment extends Fragment &#123;    public static final String TAG = &quot;哦右边的碎片&quot;;    @Override    public void onAttach(Context context)&#123;        super.onAttach(context);        Log.d(TAG,&quot;onAttach&quot;);    &#125;    @Override    public void onCreate(Bundle savedInstanceState)&#123;        super.onCreate(savedInstanceState);        Log.d(TAG,&quot;onCreate&quot;);    &#125;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)&#123;        Log.d(TAG,&quot;onCreateView&quot;);        View view = inflater.inflate(R.layout.right_fragment,container,false );        return view;    &#125;    @Override    public void onActivityCreated(Bundle savedInstanceState)&#123;        super.onActivityCreated(savedInstanceState);        Log.d(TAG,&quot;onActivityCreated&quot;);    &#125;    @Override    public void onStart()&#123;        super.onStart();        Log.d(TAG,&quot;onStart&quot;);    &#125;    @Override    public void onResume()&#123;        super.onResume();        Log.d(TAG,&quot;onResume&quot;);    &#125;    @Override    public void onPause()&#123;        super.onPause();        Log.d(TAG,&quot;onPause&quot;);    &#125;    @Override    public void onStop()&#123;        super.onStop();        Log.d(TAG,&quot;onStop&quot;);    &#125;    @Override    public void onDestroyView()&#123;        super.onDestroyView();        Log.d(TAG,&quot;onDestroyView&quot;);    &#125;    @Override    public void onDestroy()&#123;        super.onDestroy();        Log.d(TAG,&quot;onDestroy&quot;);    &#125;    @Override    public void onDetach()&#123;        super.onDetach();        Log.d(TAG,&quot;onDetach&quot;);    &#125;&#125;\n\n碎片类型基本的碎片可以分为如下所示的三种：\n\n单帧碎片 - 单帧碎片被如移动电话之类的手持设备使用。一个碎片如同一个视频一样显示。\n列表碎片 - 包含有特殊列表视图的碎片被叫做列表碎片。\n碎片过渡 - 与碎片事务一起使用。可以从一个碎片移动到另外一个碎片。\n\n2、动态加载布局的技巧限定符（Qualofiers）activity_main.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;fragment        android:id=&quot;@+id/left_fragment&quot;        android:name=&quot;com.example.myapplication.LeftFragment&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_weight=&quot;1&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt;\n\nlarge/activity_main.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;horizontal&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;&gt;    &lt;fragment        android:id=&quot;@+id/left_fragment&quot;        android:name=&quot;com.example.myapplication.LeftFragment&quot;        android:layout_width=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:layout_height=&quot;match_parent&quot;/&gt;    &lt;fragment        android:id=&quot;@+id/right_fragment&quot;        android:name=&quot;com.example.myapplication.RightFragment&quot;        android:layout_width=&quot;0dp&quot;        android:layout_weight=&quot;1&quot;        android:layout_height=&quot;match_parent&quot;/&gt;&lt;!--    layout/activity_main布局只包含一个碎片，即单页模式，而layout-large/activity_main布局包含了两个碎片，即双页模式。--&gt;&lt;!--    其中large就是一个限定符，那些屏幕被认为是large的设备就会自动加载layout-large文件夹下的布局文件，而小屏幕的设备则还是会加载layout文件夹下的布局。--&gt;&lt;/LinearLayout&gt;\n\n为了适配不同屏幕大小的android手机或android平板，有时候就需要利用限定符来为不同的屏幕设定不同的布局文件。 android中一些常用的限定符如下所示：\n\n\n\n屏幕特性\n限定符\n描述\n\n\n\n屏幕尺寸\nsmall\n小屏幕\n\n\n\nnormal\n基准屏幕\n\n\n\nlarge\n大屏幕\n\n\n\nxlarge\n超大屏幕\n\n\n屏幕密度\nldpi\n&lt;&#x3D;120dpi(低分辨率设备)\n\n\n\nmdpi\n&lt;&#x3D; 160dpi(中等分辨率设备)\n\n\n\nhdpi\n&lt;&#x3D; 240dpi(高分辨率设备)\n\n\n\nxhdpi\n&lt;&#x3D; 320dpi(超高分辨率设备)\n\n\n\nxxhdpi\n&lt;&#x3D; 480dpi(超超高分辨率设备)\n\n\n\nxxhdpi\n&lt;&#x3D; 640dpi(只用来存放icon)\n\n\n\nnodpi\n与屏幕密度无关的资源.系统不会针对屏幕密度对其中资源进行压缩或者拉伸\n\n\n\ntvdpi\n介于mdpi与hdpi之间,特定针对213dpi,专门为电视准备的,手机应用开发不需要关心这个密度值.\n\n\n屏幕方向\nland\n横向\n\n\n\nport\n纵向\n\n\n屏幕宽高比\nlong\n比标准屏幕宽高比明显的高或者宽的这样屏幕\n\n\n\nnotlong\n和标准屏幕配置一样的屏幕宽高比\n\n\n","categories":["Android学习"],"tags":["Android"]},{"title":"Android 第三章","url":"/2022/07/05/android-%E7%AC%AC%E4%B8%89%E7%AB%A0/","content":"常用控件的使用方法TextView&lt;TextView    android:id=&quot;@+id/text_view&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:gravity=&quot;center&quot;    android:textSize=&quot;24sp&quot;    android:textColor=&quot;#00ff00&quot;    android:text=&quot;This is TextView&quot;/&gt;\n\nandroid:gravity指定文件的对齐方式，可选值有top,bottom,left,right,center等，可以用”|“来同时指定多个值\nandroid:textSize属性指定文字的大小\nandroid:textColor属性指定文字的颜色\nButton&lt;Button    android:id=&quot;@+id/button&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;Button&quot;/&gt;&lt;!--我们在布局文件里设置的文字是&quot;Button&quot;，但最终显示的结果却是&quot;BUTTON&quot;。这是由于系统会对Button中的所有英文字母进行大写转换，如果不是你想要的效果，可以使用如下配置来禁用这一默认特性--&gt;&lt;!-- android:textAllCaps=&quot;false&quot;--&gt;\n\n\n\n在MainActivity中为Button的点击事件注册一个监听器\n有出现监听器Toast.makeText不能显示的问题\n\n解决办法\nstep1：进入AVD Manager\nstep2：点击对应虚拟设备顶最右边的倒三角\nstep3：选择Wipe Data后再次启动模拟器\n\nEditText允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理\n&lt;EditText    android:id=&quot;@+id/edit_text&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:hint=&quot;Type Something Here&quot;    android:maxLines=&quot;2&quot;          /&gt;&lt;!--android:hint属性指定了一段提示性的文本--&gt;&lt;!--android:maxLines指定EditText的最大行数--&gt;\n\nImageViewImageView是用于在界面上展示图片的一个控件\n图片通常都是放在以”drawable“开头的目录下，不过由于这个目录没有指定具体的分辨率，所以一般不使用它来放置图片。这里我们在res目录下新建一个drawable-xhdpi目录\n&lt;ImageView    android:id=&quot;@+id/image_View&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:src=&quot;@drawable/bomb&quot;    /&gt;\n\n我感觉有图片大小问题，但是不知道怎么解决。换了个小的就ok啦\nProgressBarProgressBar用于在界面上显示一个进度条，表示我们的程序正在加载一些数据\nAndroid控件的可见属性：所有的Android控件都具有这个属性，可以通过android:visibility进行指定，可选值有3种：visible、invisible、gone。\n\nvisible表示控件是可见的，这个值是默认值，不指定android：visibility时，控件都是见的；\ninvisible表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了；\ngone则表示控件不仅不可见，而且不再占用任何屏幕空间。\n\n使用setVisibility()方法，可以传入View.VISIBLE、View.INVISIBLE和View.GONE 三种值。\n&lt;ProgressBar    android:id=&quot;@+id/progress_bar&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;\n\n我们还可以给ProgressBar指定不同的样式\nAlertDialogAlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶与所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此AlertDialog一般都是用于提示一些非常重要的内容或者警告信息。\n在MainActivity中\nProgressDialogProgressDialog和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是，ProgressDialog会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心等待。\n4中基本布局线性布局&#x2F;LinearLayout\nandroid:orientation属性指定：vertical，horizontal\n注意：horizontal，内部的控件不能将宽度指定为match_parent；同理vertical，内部的控件不能将高度指定为match_parent\n\nandroid:layout_gravity属性\nandroid:gravity用于指定文字在控件中的对齐方式，\nandroid:layout_gravity用于指定控件在布局中的对齐方式。\nandroid:layout_gravity的可选值和android:gravity差不多，这两个在相对布局都是没用的\n\n但注意：LinearLayout的排列方向是horizontal时，只有垂直方向上的对齐方式才会生效，因为此时水平方向上的长度是不固定的，没添加一个控件，水平方向上的长度都会改变，因而无法指定该放下上的对齐方式；同样的道理，当LinearLayout的排列方向是vertical时，只有水平方向上的对齐方式才会生效。\n\nandroid:layout_weight属性\n这个属性允许我们使用比例的方式来指定控件的大小\n我们使用了android:layout_weight属性，此时控件的宽度就不应该再由android:layout_width来决定，指定成0dp是一种比较规范的写法。\n\n\n相对布局&#x2F;RelativeLayout和LinearLayout的排列规则不同，RelativeLayout显得更加随意一些，它可以通过相对定位的方式让控件出现在布局的任何位置。\n\n相对于父布局进行定位\nandroid:layout _alignParentLeft、android:layout _alignParentTop、android:layout _alignParentRight、android:layout _alignParentBottom、android:layout _centereInParent\ne.g android:layout _alignParentLeft=&quot;true&quot;\n\n相对于控件\nandroid:layout_below、android:layout_above、android:layout_toRightOf、android:layout_toLeftOf\ne.g android:layout_below=&quot;id/button3&quot;\n\n\n帧布局&#x2F;FrameLayout这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角\n用的很少\n介绍碎片\n百分比布局在这种布局中，我们可以不再使用wrap_content、match_parent等方式来指定控件的大小，而是允许直接指定控件在布局中所占的百分比，这样的话就可以轻松实现平分布局甚至是任意比例分割布局的效果。\n由于LinearLayout本身已经支持按比例指定控件的大小了，因此百分比布局只为Frame-Layout和RelativeLayout进行了功能扩展，提供了PercentFrameLayout和PercentRelative这两个全新的布局。\n在项目的build.gradle中添加百分比布局库的依赖，就能保证百分比布局在Android所有系统版本上的兼容性了\n打开app&#x2F;build.gradle文件，在dependencies闭包中添加如下内容：\ncompile &#39;com.android.support:percent:24.2.1&#39;\n一些补充在不同的布局中layout_gravity和gravity是否有区别在相对布局中layout_gravity和gravity不起任何作用\ngravity在线性布局中不起任何作用，layout_gravity在线性布局中起作用\n当我们使用 android:orientation&#x3D;“vertical” 时， android:layout_gravity只有水平方向的设置才起作用，垂直方向的设置不起作用。即：left，right，center_horizontal 是生效的\n当我们使用android:orientation&#x3D;“horizontal” 时， android:layout_gravity只有垂直方向的设置才起作用，水平方向的设置不起作用。即：top，bottom，center_vertical 是生效的\n属性src和background的区别1.background根据ImageView组件给定的长宽进行拉伸，而src就存放的是原图的大小，不会进行拉伸。src是图片内容（前景），background是背景，二者可以同时使用。\nImageButton 是带图标的Button控件，有src的属性，也就是设置他的图标，也有一个所有控件公有的属性background， 这个也可以设置它的“图标”。\n其实，src才是设置图标，而background只是设置背景。\n重要的是，background是底层的图片资源，src是覆盖在background上面的资源，他们可以叠加使用，实现选中的效果。在ActivityGroup用到。\n\n2.scaleType只对src起作用；background可设置透明度，比如在ImageButton中就可以用android:scaleType控制图片的缩放方式。\nFIT_XY：对原图宽高进行放缩，该放缩不保持原比例来填充满ImageView。\nMATRIX：不改变原图大小从ImageView的左上角开始绘制，超过ImageView部分不再显示。\nCENTER：对原图居中显示，超过ImageView部分不再显示。\nCENTER_CROP：对原图居中显示后进行等比放缩处理，使原图最小边等于ImageView的相应边。\nCENTER_INSIDE：若原图宽高小于ImageView宽高，这原图不做处理居中显示，否则按比例放缩原图宽(高)是之等于ImageView的宽(高)。\nFIT_START：对原图按比例放缩使之等于ImageView的宽高，若原图高大于宽则左对齐否则上对其。\nFIT_CENTER：对原图按比例放缩使之等于ImageView的宽高使之居中显示。\nFIT_END：对原图按比例放缩使之等于ImageView的宽高，若原图高大于宽则右对齐否则下对其。\n\n线性布局中如果有两个及以上的控件，需要加一个属性才不会报错\n&#x2F;&#x2F;垂直排列android:orientation&#x3D;”vertical”&#x2F;&#x2F;水平排列android:orientation&#x3D;”horizontal”\n\nlayout_weight属性的用法和意义意义：layout_weight属性的意义就是将父控件的剩余空间按照设置的权重比例再分配，也就是在布局的时候，系统先按照view的layout_width和layout_height来布局，然后再根据layout_weight对view的位置进行调整。\nlayout_weight默认为0\n1.额外空间，指的是剩余空闲空间, 额外空间将在权重大于0的所有视图中按比例分配。如下，总权重为1+1&#x3D;2\n第一个控件是比第二个控件占的空间小的，即w(12345)+1&#x2F;2空闲空间&lt; w(123456)+1&#x2F;2控件\n&lt;LinearLayout   android:orientation=&quot;horizontal&quot;&gt;  &lt;TextView     android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_height&quot;    android:layout_weight=&quot;1&quot;    android:text=&quot;12345&quot;/&gt;    &lt;TextView     android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_height&quot;    android:layout_weight=&quot;1&quot;    android:text=&quot;123456&quot;/&gt; &lt;/LinearLayout&gt;\n\n\n 如果我们让控件的宽度定义为layout_width&#x3D;”0dp” ，这样比如2个控件的 layout_weight&#x3D;”1” 就可以各自50%平分整个空间了，因为：0 + 1&#x2F;2空闲空间 &#x3D; 0 + 1&#x2F;2空闲空间。\n2.默认layout_weight为0，所以如果这么写：&lt;LinearLayout    android:orientation=&quot;horizontal&quot;&gt;     &lt;TextView     android:layout_width=&quot;40dp&quot;     android:layout_height=&quot;match_parent&quot;     android:background=&quot;#000&quot; /&gt;     &lt;Button     android:layout_width=&quot;0dp&quot;     android:layout_height=&quot;match_parent&quot;     android:layout_weight=&quot;1&quot;/&gt;     &lt;TextView     android:layout_width=&quot;40dp&quot;     android:layout_height=&quot;match_parent&quot;     android:background=&quot;#888&quot; /&gt;   &lt;/LinearLayout&gt;\n\n 则总权重为1，即Button占了所有剩余空闲空间，无论它在哪个位置\n3.在排列方向上设置了match_parent, 如下，权重为2，1，2  &lt;LinearLayout     android:layout_width=&quot;match_parent&quot;     android:layout_height=&quot;match_parent&quot;     android:orientation=&quot;horizontal&quot;&gt;     &lt;Button       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;wrap_content&quot;        android:text=&quot;1&quot;       android:layout_weight=&quot;2&quot;/&gt;     &lt;Button       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;wrap_content&quot;       android:text=&quot;2&quot;       android:layout_weight=&quot;1&quot;/&gt;     &lt;Button       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;wrap_content&quot;       android:text=&quot;3&quot;       android:layout_weight=&quot;2&quot;/&gt;&lt;/LinearLayout&gt;\n\n 运行结果如下:\n\n分析：因为设置的都是match_parent，所以如果没有设置权重，三个Button只会显示第一个,其他会被覆盖，但是设置了权重后， 我们就按三个Button给定的width&#x3D;match_parent计算剩余空间\n剩余空间&#x3D;1个match_parent空间-3个match_parent空间&#x3D; -2个match_parent空间（负2）\n所以\nButton1所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*2&#x2F;5 &#x3D; 1&#x2F;5个match_parent空间\nButton2所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*1&#x2F;5 &#x3D; 3&#x2F;5个match_parent空间\nButton3所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*2&#x2F;5 &#x3D; 1&#x2F;5个match_parent空间\n所以在统一设置match_parent时，会有这么一个特性，权重越大，空间越小。\n4.在某个控件权重刚好为另外的所有控件权重之和时，这个控件会消失。如权重变为1，2，3\n  &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:orientation=&quot;horizontal&quot;&gt;        &lt;Button            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;             android:text=&quot;1&quot;            android:layout_weight=&quot;1&quot;/&gt;        &lt;Button            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;2&quot;            android:layout_weight=&quot;2&quot;/&gt;        &lt;Button            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;3&quot;            android:layout_weight=&quot;3&quot;/&gt;&lt;/LinearLayout&gt;\n\n运行结果如下:\n\n同样的算法：\nButton1所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*1&#x2F;6 &#x3D; 2&#x2F;3个match_parent空间\nButton2所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*2&#x2F;6 &#x3D; 1&#x2F;3个match_parent空间\nButton3所占空间 &#x3D; 1个match_parent空间+（-2个match_parent空间）*3&#x2F;6 &#x3D; 0个match_parent空间\n剩余布局大小 &#x3D; 父布局大小 - 子布局大小之和\n获取输入框的内容(用Button和EditText实现)1.获取button和editText的实例\n2.在点击事件中用String获取editText的内容\n3.用Toast打印出来\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;\tprivate EditText editText;\t@Override\tprotected void oncreate( Bundle savedInstanceState) &#123;\t\tsuper.onCreate( savedInstanceState) ;\t\tsetContentview (R.layout.activity_main) ;\t\tButton button = (Button) findViewById(R.id.button) ;        editText = (EditText)findViewById(R.id.edit_text);        button.setOnclickListener(this) ;\t&#125;\t@Override\tpublic void onclick(View v) &#123;\t\tswitch (v.getId()) &#123;\t\tcase R.id.button:\t\t\tString inputText = editText.getText().toString();       \t\tToast.makeText(MainActivity.this,inputText,Toast.LENGTH_SHORT).show();\t\t\tbreak;\t\tdefault:\t\t\tbreak;\t\t&#125;\t&#125;&#125;\n\nListViewLIstView最主要的内容其实就是适配器\n常用数据适配器\n数据适配器是数据与视图之间的桥梁，它类似于一个转换器，将复杂的数据转换成用户可以接受的方式进行呈现\n\n常用的数据适配器\n\nBaseAdapter\nSimpleAdapter\nArrayAdapter\n\n\n\n","categories":["Android学习"],"tags":["Android"]},{"title":"Android 第二章","url":"/2022/05/17/android-%E7%AC%AC%E4%BA%8C%E7%AB%A0/","content":"基本活动android:exported android:exported是Android中的四大组件 Activity，Service，Provider，Receiver 四大组件中都会有的一个属性。\n\nActivity中\n&lt;activity          ……          android:exported=[&quot;true&quot; | &quot;false&quot;]          ……/&gt;\n\n在Activity中该属性用来标示：当前Activity是否可以被另一个Application的组件启动：true允许被启动；false不允许被启动。\n如果被设置为了false，那么这个Activity将只会被当前Application或者拥有同样user ID的Application的组件调用。\nexported 的默认值根据Activity中是否有intent filter 来定。没有任何的filter意味着这个Activity只有在详细的描述了他的class name后才能被唤醒 .这意味着这个Activity只能在应用内部使用，因为其它application并不知道这个class的存在。所以在这种情况下，它的默认值是false。从另一方面讲，如果Activity里面至少有一个filter的话，意味着这个Activity可以被其它应用从外部唤起，这个时候它的默认值是true。\n\n\n在活动中使用ToastToast提醒，将短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间\nprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.first_layout);    Button button1 = (Button) findViewById(R.id.button_1);    button1.setOnClickListener(new View.OnClickListener() &#123;    @Override    public void onClick(View view) &#123;        Toast.makeText(FirstActivity.this,&quot;You clicked Button 1&quot;,Toast.LENGTH_SHORT).show();    &#125;&#125;);&#125;\n\n写法好像变了\n@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.first_layout);    Button button1 = (Button) findViewById(R.id.button_1);    button1.setOnClickListener(            view -&gt; Toast.makeText(FirstActivity.this,&quot;You clicked Button 1&quot;, Toast.LENGTH_SHORT).show());&#125;\n\n在活动中使用Menu我们可以使用 、、 三种XML元素定义 Menu，下面简单介绍一下它们：\n\n是菜单项的容器\n- 元素必须是该文件的根节点，并且能够包含一个或多个和元素\n是菜单项，用于定义MenuItem，可以嵌套元素，以便创建子菜单\n是元素的不可见容器（可选）\n可以使用它对菜单项进行分组，使一组菜单项共享可用性和可见性等属性。\n\n\n\n　　其中，是我们主要需要关注的元素，它的常见属性如下：\n\nandroid:id：菜单项(MenuItem)的唯一标识\nandroid:icon：菜单项的图标（可选）\nandroid:title：菜单项的标题（必选）\nandroid:showAsAction：指定菜单项的显示方式\n常用的有ifRoom、never、always、withText\n多个属性值之间可以使用|隔开\n\n\n\n使用menures&#x2F;menu&#x2F;main.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item        android:id=&quot;@+id/add_item&quot;        android:title=&quot;@string/Add&quot;/&gt;    &lt;item        android:id=&quot;@+id/remove_item&quot;        android:title=&quot;@string/Remove&quot;/&gt;&lt;/menu&gt;\n\nFirstActivity.java\n@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123;    getMenuInflater().inflate(R.menu.main,menu);    return true;&#125;@SuppressLint(&quot;NonConstantResourceId&quot;)@Overridepublic boolean onOptionsItemSelected(@NonNull MenuItem item) &#123;    switch (item.getItemId())&#123;        case R.id.add_item:            Toast.makeText(this,&quot;You clicked add&quot;,Toast.LENGTH_SHORT).show();            break;        case R.id.remove_item:            Toast.makeText(this,&quot;You clicked Remove&quot;,Toast.LENGTH_SHORT).show();            break;        default:    &#125;    return true;&#125;\n\n使用Intent在活动之间穿梭Intent大致可以分为两种：显式Intent和隐式Intent\n显式与隐式的跳转","categories":["Android学习"],"tags":["Android"]},{"title":"信息安全","url":"/2022/05/18/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/","content":"信息安全Robots\n搜索引擎使用spider程序自动访问互联网上的网页并获取网页信息。spider在访问一个网站时，会首先会检查该网站的根域下是否有一个叫做robots.txt的纯文本文件。您可以在您的网站中创建一个纯文本文件robots.txt，在文件中声明该网站中不想被robot访问的部分或者指定搜索引擎只收录特定的部分。\nrobots.txt 放置位置\nrobots.txt文件应该放置在网站根目录下。举例来说，当spider访问一个网站(比如http://www.ubangmang.com)时，首先会检查该网站中是否存在http://www.ubangmang.com/robots.txt这个文件，如果 Spider找到这个文件，它就会根据这个文件的内容，来确定它访问权限的范围。\nrobots.txt 格式\nUser-agent:\n该项的值用于描述搜索引擎robot的名字。如果该项的值设为*，则对任何robot均有效，在”robots.txt”文件中，”User-agent:*”这样的记录只能有一条\n Disallow: 该项的值用于描述不希望被访问的一组URL，这个值可以是一条完整的路径，也可以是路径的非空前缀，以Disallow项的值开头的URL不会被robot访问。\n例 如”Disallow: &#x2F;help”禁止robot访问&#x2F;help*.html、&#x2F;help&#x2F;index.html， 而”Disallow: &#x2F;help&#x2F;”则允许robot访问&#x2F;help*.html，不能访问&#x2F;help&#x2F;index.html。\n允许robot访问该网站的所有url，在”&#x2F;robots.txt”文件中，至少要有一条Disallow记录。如果”&#x2F;robots.txt”不存在或者为空文件，则对于所有的搜索引擎robot，该网站都是开放的。\nAllow:\n该项的值用于描述希望被访问的一组URL，与Disallow项相似\n特别注意的是Disallow与Allow行的顺序是有意义的，robot会根据第一个匹配成功的 Allow或Disallow行确定是否访问某个URL\nerxff和referer\n关于xff和referer维基百科：\nX-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。\nXXF的格式：\nX-Forwarded-For: 本机IP, 代理1IP, 代理2IP, 代理2IP\n其中\nreferer（来源） 是http的拓展头部，作用是记录当前请求页面的来源页面的地址。\n（网页1中有个链接，你点链接，弹出网页2\n此时你抓网页2的包，会看到\nreferer：网页1）\nReferer的作用1.防盗链。\n设置网页对请求的判断，\n访问网页2，想要我本人从网页2下载某些数据，不想让别人下载\n那我就拥有个私人网页1，没有公开，我从网页1访问网页2\n网页2一看请求的Referer：我靠，是网页!!!!!顶级VVVIP，惹不得，他要啥给啥\n如果不是，权限一个都没有\n这是不是就达到防盗链的效果了？\n2.防止恶意请求。\n比如我的网站上，静态请求是*.html结尾的，动态请求是*.shtml，那么由此可以这么用，所有的*.shtml请求，必须 Referer 为我自己的网站。\n\n参考：\n[1]: https://blog.csdn.net/weixin_43639682/article/details/113879449\t“引用一”[2]: https://blog.csdn.net/slj1552560/article/details/113825428\t“引用二”\n\n","tags":["CTF","信息安全"]},{"title":"Hello World","url":"/2022/05/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]